<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture</title>
    <link>https://hello-world-example.github.io/Architecture/</link>
    <description>Recent content on Architecture</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://hello-world-example.github.io/Architecture/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Architecture/_sidebar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Architecture/_sidebar/</guid>
      <description> EDA  事件驱动架构 简介  一致性协议  CRDT    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Architecture/docs/DDD/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Architecture/docs/DDD/README/</guid>
      <description>领域驱动设计 精简版 译序一 在 2004 年之前的某一天，我和所在部门的一个设计师进行沟通，当时他为自己的一个思路兴奋不已，而我要做的事情就是跟他讨论清楚他头脑中的那个想法，然后写出需求和设计文件来。大家可能会注意到，很多时候，需求是从设计中反推出来的，这被一些专家称为“需求的反向工程”。其实我更多地认为这是由于我们现在糟糕的工作现状决定的，有诸多的因素导致需求或者设计被局限在仅有的几个人的知识体系中，但如果有心去细察，会发现他们各自的理解又各不相同。
回到刚才说到的那次沟通上，当那个设计师把自己的得意之作描述完毕后，我在纸上用 UML 图画出了他的主题思路，然后我们针对细节开始探讨并在图上改改画画。最后的修订结果显示，他的很多&amp;rdquo;创举&amp;rdquo;是多余的，经过精简后的 UML 基本上颠覆了他原有的思路。现在我还记得那位同事的一声叹息：“一周的功夫白费了……”其实在整件事情中，他有他的得失，我也有我的收获和困惑：我意识到对统一的核心模型进行探讨和简化的重要性，但应该如何把这样的过程程式化，让它在更多的同事的工作中发挥作用呢？
这样的问题纠缠了我好久，终于有一天，我得到了一本如字典般的硬皮 Domain Driven Design（我们亲切地称它为“DDD”）原版书，从中找到了答案。然后，我参与了 DDD 中文版的审校工作和DDD 注释版的注释工作。再后来，InfoQ 中文站的总编霍泰稳又邀请我一起做了 Domain Driven Design Quickly 这本书的翻译工作。
曾经有人要我用简练的词汇描述 DDD 的中心思想，我个人认为这是一个比较难的工作，但我愿意去尝试。我的回答是&amp;rdquo;关注精简的业务模型及实现的匹配&amp;rdquo;：
 如果你了解&amp;rdquo;模型&amp;rdquo;的定义是对现实的有选择性的精简，然后用这样的观点去读 DDD 这本书，你就会发现，DDD 其实没有什么太多的新鲜玩意，它更多地是可以看作是面向对象思潮的回归和升华。在一个&amp;rdquo;万事万物皆对象&amp;rdquo;的世界里，哪些对象是对我们的系统有用的？哪些是对我们拟建系统没有用处的？我们应该如何保证我们选取的模型对象恰好够用？ 前面的选择性问题只是解决了一个初步框选的问题，对象并不是独立存在的，它们之间有着千丝万缕的联系。这种扯不断理还乱的联系构成了系统的复杂性。一个具体的体现就是，我们修改了一处变更，结果引发了一系列的连锁反应。虽然对象的封装机制可以帮我们解决一部分问题，但那只是有限的一部分。我们应该如何在一 个更高点的层次上，通过保留对象之间有用的关系去除无用的关系，并且限定变更影响的范围以来降低系统的复杂度呢？ 在 DDD 以及传统 OO 的观点中，业务而不是技术是一个开发团队首先要关注的内容，众多的框架和平台产品也在宣称把开发人员解放出来，让他们有更多的精力去关注业务。但是，当我们真正去看待时，会发现，开发人员大多还是沉溺于技术中，对业务的理解和深入付出的太少太少。其实要解决这个问题，就要先看清楚我们 提炼出来的模型,在整个架构和整个开发过程中所处的位置和地位。我们经常听到两个词，一个是 MDD（模型驱动设计），一个是MDA（模型驱动架构）。如果 DDD 特别关注的是&amp;rdquo;M&amp;rdquo;(以及其实现)，那么，这个 M 应该如何与架构和开发过程相融合呢？我经常会看到我们辛苦提取出来的领域模型被肢解后，分散到系统的若干角 落。这真是一件可怕的事情，因为一旦形成了&amp;rdquo;人脑拼图&amp;rdquo;，就很难再有一个人将它们一一复原，除非这个人是个天才。 很多面向对象的教材，都会告诉你若干的技巧，让你去机械化地处理模型和对象实现，但是这些教材通常会忽略一个大的上下文环境，就是应该由哪些具有什么样素质和技能的人来处理模型和对象实现,或者说白了，就是应该用什么样的团队模型来匹配业务模型。不同的模型，需要不同的团队模型的支撑，不同的团队模型也会让一个模型实现更优秀或者更糟糕。 相信很多人读过 ATM 机的例子，你发现自己彻底明白了用例应该怎么编写、模型怎么提取和实现，但是当你信心十足地去开始你自己的项目时，你又会发现你的思路片段化了，所有你明白了的技能在你的新项目中好像用不上。算了，还是老的工作思路和工作方式比较顺手，于是一切都照旧会到了老的套路上。那么，面向对象技术或者说我们提炼出来的模型应该如何在大型项目/团队中使用呢？我们是应该要求一个项目使用统一的模型，还是应该把它们分成不同的模型？我们应该如何抉择？  在实际的应用过程中，我相信每一个有心人都会提出比我在这里列举出来的还要多的问题，没有关系，DDD 这本书都能给你所需的答案。
当然，“DDD”作为传统 OO 范型的探索和升华版，也存在着一些不足和未涉及的领域，例如：在安全、权限方面的考虑，其基本构造块的适用范围和决策标准，与开发框架之间更好的融合性等问题。还好，我们都知道&amp;rdquo;尽信书不如无书&amp;rdquo;的道理，在阅读任何著作时，都应该带着自己的疑惑和批判精神去阅读，你的任何关于 DDD的深层思考和讨论，都可以在它的配套网站或者 InfoQ 中文站网站中发表。
如果你认为阅读 DDD 这么一本如字典版的大厚书时间上不太允许，那么请允许我为你介绍一本简化版的小书 Domain Driven Design Quickly，经过我们的努力，InfoQ 中文站已经将其翻译成中文版 ——《领域驱动设计精简版》，并作为国庆礼物奉献给大家！
那还等什么呢，祝你开卷有益，阅读愉快！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hello-world-example.github.io/Architecture/docs/EDA/Introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hello-world-example.github.io/Architecture/docs/EDA/Introduction/</guid>
      <description>事件驱动架构 简介 通过事件进行应用程序的设计是自20世纪80年代后期以来的一种实践。我们可以在前端或后端的任何地方使用事件。当按下按钮时，某些数据发生更改或执行某个后端动作。
但是事件究竟是什么呢？我们什么时候应该用它呢？缺点是什么？
What / When / Why 当类或组件之间内聚性很高，它们的耦合度应该很低，也就是说当组件需要相互协作调用时，比如我们假设一个 组件A 需要触发 组件B 中的一些逻辑，自然的方式是直接让 组件A 调用 组件B 中的一个方法，但前提是 A 必须知道 B 的存在，这样它们之间就是耦合的，A 必须依赖于 B 了，这会使得系统更难以改变和维护。因此，这里可以使用事件来防止这种直接调用的耦合。
如果我们有一个只负责组件B的工作团队，那么他们则可能不需要与负责组件A的团队进行交流，直接针对组件A中的逻辑改变在组件B中做出相对反应。两个组件团队可以独立发展（注：微服务特点之一）， 我们的应用系统变得更灵活。
即使在同一个组件团队中，有时候我们不需要在同一 请求/响应 中立即执行一个动作的结果，只要异步执行这个动作，比如发送电子邮件。在这种情况下，我们可以立即向用户返回响应，并以异步方式发送电子邮件，并避免让用户等待发送电子邮件。
不过，如果我们不加区别地使用它，也有危险。我们会遇到逻辑流程的风险，这些逻辑流程在概念上是高度凝聚力的，但是通过采取脱钩机制的事件连接在一起。换句话说，应该在一起的代码将被分开，并且难以跟踪它的流程（类似于goto语句），不易于理解：可能是意大利面一样混在一起！
为了防止将我们的代码库变成一大堆意大利面条，我们应该将事件的使用限制在明确的情况下。根据我的经验，有三种使用事件的情况：
 去耦组件
 执行异步任务
 跟踪状态变化（审核日志）
  去耦组件（微服务） 当 组件A 执行的逻辑需要触发 组件B 的逻辑时，不要直接调用它，我们可以将触发事件发送到事件分派器。组件B 将侦听调度程序中的特定事件，并在事件发生时执行操作。
这意味着 A 和 B 都将取决于调度器和事件，但他们之间将不会知道对方存在，它们将被解耦。
理想情况下，调度员和事件都不应该在两个组件之间存在：
 调度员应该是完全独立于我们应用程序的库，因此使用依赖管理系统安装在通用位置。 事件是我们的应用程序的一部分，应该在两个组件之间生存，组件之间通过事件进行通讯（结构上解耦，行为上耦合）。事件在组件之间共享，它是应用程序的核心部分。事件在 DDD 中属于共享内核 Shared Kernel的一部分。这样，两个组件都将依赖于共享内核，但彼此不会意识到。然而在单体应用程序中，为方便起见，可以将其放在触发事件的组件中。   DDD共享内核
 明确界定指定团队同意分享的领域模型的一些子集。保持这个内核很小。 这个明确共享的东西有特殊的地位，如果没有与其他团队协商，不应该改变。  —— Eric Evans 2014， 领域驱动设计参考</description>
    </item>
    
  </channel>
</rss>